# 技术细节

## 0x00 前言

在饥荒里听说过Luajit的玩家应该都依稀记着多年前paintdream大佬制作的[DontStarveLuaJIT](https://paintdream.github.io/DontStarveLuaJIT/)补丁。在我断断续续的饥荒游戏生涯里，也曾在2019年尝鲜式使用过这个补丁。与paintdream相似，制作一个x64版的Luajit补丁也不是我一开始就计划好了的事。2021年因疫情封城月余，每天花很多时间与朋友们闲逛在永恒大陆，由于我们的电脑都并不是新款，又打了很多大型mod，即使将地面与地洞的服务器分担在两台电脑上，每当遇到青蛙雨、路过蜘蛛矿场、发生不妥协模组的夜间事件，时令龙蝇开火车时，总会卡成ppt，甚至强行关闭客户端退出也难逃死亡厄运，那时候还没有暂停功能，大家也总是玩的不是很爽。好在22年初春一位朋友换了电脑，尽管他不玩饥荒也愿意把电脑借我们挂在后台开服务器，威尔逊的寿命才突破三百。

## 0x01 预备

也许是对自己宝贝电脑的信心，也许是对Kiel优化的不满，我始终觉得Core i5-8300h也能让我们流畅旅行。当我回到DontStarveLuaJIT的储存库时，却收到了停止维护与不支持x64的噩耗，即使使用32位的`Don't Starve Together/bin/dontstarve_dedicated_server_nullrenderer.exe`也无法正确运行。不仅如此，时至今日饥荒的全部lua脚本仍运行在单一线程中[^1]，无法完全利用8代i5的8个逻辑处理器。在经过考察以后，我决定跟随paintdream的思路，采取hook方法，映射饥荒可执行文件中静态编译的lua51到外部挂接的luajit动态链接库中，在此基础上，尝试将lua脚本变更为多线程执行[^2]。

## 0x02 初入

说干就干，git clone下来DontStarveLuaJIT储存库，看看这个库是怎么实现的，为什么到64系统下就不能用了，但惊奇的发现库里的commit history被强制推送覆盖，全部丢失了，也就是说无法查看作者的修改历史。好在查看forks发现有不少其他人的分支，经过文件比对，我选择了其中一个[fork版本](https://github.com/hyiltiz/DontStarveLuaJIT)作为参考。

以下是我对DontStarveLuaJIT最终版本各子目录及文件的简单理解。

补丁的主要文件都存在于`src/`目录下，`DontStarveLuaJIT.sln`的内容说明这是一个Visual Studio 2008工程，至于后面跨平台移植到Linux上是仍采用vs编辑还是linux上直接编辑并gcc编译方式已不可考。但根据库Readme的说明能够确定Linux上需要使用gcc-4.8.4来编译lua51库。经过文件夹比对可以确定，`src/lua51`与`src/luajit`分别是`lua5.1.4`官方发布版源码和基于[LuaJIT-2.1.0-beta2](https://github.com/LuaJIT/LuaJIT/commit/3e4a196777450f7db11067e93a17655ba3ee0d53)的修改版本，具体修改内容大多数都在[paintdream的知乎专栏](https://zhuanlan.zhihu.com/p/24570361)有介绍。`src/DontStarveInjector`中是主要patch代码，实现了一个在win32平台上利用系统api向进程注入动态链接库的插件，其主要技术在专栏中也有讲解，我就不再班门弄斧了。`DontStarveInjector.cpp`文件是主要实现注入的代码部分，其主要功能与`src/DontStarveInjectorLinux/main.cpp`相同，是在被注入到饥荒主进程后，加载`lua51`动态链接库获取各函数特征码，然后搜索`.text`段机器码，寻找与已知特征码最匹配的部分作为已知函数被静态编译后的入口，然后加载修改后的`luajit`动态链接库，劫持入口转发到`luajit`对应函数入口处。由此实现在运行时替换饥荒内置的lua引擎的效果。

## 0x03 分析

那么原理很简单，加载——搜索——劫持——注入，为什么到x64架构下不能用了呢？

这是因为机器码没法直接搜索，由于变长指令集的存在，如果不知道哪几个二进制码属于同一条指令，是没法理解这段机器码的意义的，同时，不同指令的不同段可能会有雷同，甚至长指令的二进制码中完全包含短指令的二进制码也是完全可能的[^3]。由此，在进行搜索前必须将机器码反汇编为汇编指令，然后再对汇编指令进行相似度分析。问题就出在这个反汇编过程上：DontStarveLuaJIT所使用的反汇编引擎是流传在网上多年的`XDE v1.02 eXtended length disassembler engine`，其原作者来源已不可考，但是在搜索相关资料时可以明确了解这是一个x86反汇编引擎，在x64平台上失效就很好理解了。因此如果想将此patch移植到x64平台，首要任务就是替换一个反汇编引擎。

然而相信大家和我都有同样的疑问，饥荒仍保留了32位的可用主程序，为什么使用32位主程序与此补丁仍然无法正确运行呢？这里容我先卖个关子。

## 0x04 开工

既然知道了主要问题在哪，那就先去弄一个支持x64的反汇编引擎吧。此外，我决定将我的补丁设计为基于linux平台，从而可以利用docker快速发布和安装。

寻找一个反汇编引擎并不是很复杂的事，比如Capstone、udis86、BeaEngine、和一些。但他们有的太过臃肿，有的调用方法过于复杂，还有一些是利用linux的包管理软件发布的。这些都不是很符合我的期望，而小型轻便的反汇编框架又多都少少有一些bug，star也都不多。

经过搜索和测试，我决定选择一个较小众的[LengthDisasm](https://github.com/wolk-1024/LengthDisasm)作为基础，并对其进行修改和定制化。这个引擎只有两个文件，通过阅读源码可以看出作者完全根据intel变长指令集白皮书一步一步实现的[^4]，因此，如果在使用过程中遇到了问题相较于其他引擎更容易排查和修正。

## 0x04 准备环境

在正式开始工作之前，我们还需要一个安装了gcc-4.8.4的linux环境。根据DontStarveLuaJIT的说明，可以安装`Ubuntu 14.04 LTS`来使用自带的`gcc-4.8.4`。但这个版本的系统实在太古老了，开发时所需的其他工具我实在用不惯。于是我采取了另个一办法。

我先正常安装了`Ubuntu 20.04 LTS`版本，然后正常安装开发所需依赖，然后换源为`14.04 LTS`，安装`gcc-4.8.4`，最后创建软连接使默认gcc即调用`gcc-4.8.4`[^5]。

开发工具我选择使用VSCode从主机远程到docker容器内进行开发（这个操作给我后面埋下了很大的一个坑）。

## 0x05 站在大佬的肩膀上

既然DontStarveLuaJIT主要出问题的点在于他的反汇编引擎有问题，而且原作者对于饥荒内置引擎的诸多bug进行了反向修正，我为什么不把他的相关patch拿过来呢？

拉取LuaJIT-2.1.0-beta2到LuaJIT目录作为初始化，提交到git后删除目录内的全部文件，将`DontStarveLuaJIT/src/luajit`的内容拷贝过来，对比检查每一处`git diff`列出的改动，然后提交。从此，我们就可以在paintdream的基础上继续开发了。再次向大佬表达感谢！

## 0x06 尝试第一次hook

起初我以为只是简单的替换一下反汇编引擎，然后在`src/DontStarveInjectorLinux/main.cpp`中对新引擎做适配就可以成功运行，但从结果上看我还是过于乐观了。设置好`LD_PRELOAD`然后启动，虽然服务器启动过程中就崩溃退出了，但log显示成功注入，大部分函数都有hook点位。（但这些点位正确吗？根据最后真正成功运行起来的hook地址对照，这次hook的大部分点位都是错的）

和paintdream大佬的第一步一样，无论如何，起码证明我们hook掉官方函数捅娄子的能力。

暂且不去管那些已经成功hook的点位是否正确，先看看为什么有的函数hook失败。

## 0x07 重新开始

#### 先来回顾一下我们确定hook点的原理：

1. 拿到饥荒可执行文件载入内存后.text段的起止地址
2. 利用dlsym拿到lua51中某一函数入口地址
3. 利用反汇编引擎拿到此函数的特征码
4. 计算.text段所有语句的特征码，然后与已知函数特征码进行交叉比对，从而确定被静态编译到饥荒后的各函数入口具体地址
5. 利用dlsym拿到luajit中对应函数入口地址，然后采用内联hook方式，覆写.text段对应函数的机器码

#### 然后逐一分析可能遇到的问题及解决办法:

首先，我们拿到的`.text`段地址一定就是饥荒程序的吗？

`LD_PRELOAD`的作用是在执行任意程序之前注入此环境变量中设置的动态链接库。我们在vscode中启动调试命令时，会自动执行`bash -c exec`来启动我们的调试进程，而我们的链接库也就被注入到了`exec`程序中，因此我们拿到的.text段地址实际上是`exec`的.text段地址。这个问题在初期一直困扰我。

其次，函数特征码的生成方法需要修改吗？

- 64位的机器码与x86下有很大的不同，首当其冲的就是在多字节NOP[^6]。使用IDA查看64位编译的lua51和饥荒程序，可以看到在`select...case...`、`if...else...`、`for...`语句段结束后大多有多字节nop进行补位来对齐`align 10h`，原作者发布的`LengthDisasm`是不支持多字节nop指令的解析的。这个简单，加上就好。
- DontStarveLuaJIT生成特征码截止方法是取前64个字节或者遇到ret指令（机器码0xC3）；对于跳转指令（0xe8和0xe9两个短距离相对跳转）则取其目标地址中的前4个字节作为操作数的特征值；对mov或push指令（0x68 push、0xc7 move），则取其操作数作为特征值；其余普通指令直接复制作为特征值。分析这种特征码生成方法不难发现有如下问题：①对于跳转的目标函数内容采样过少②部分函数结束处是jmp指令，上述方法生成特征码时计算了部分此函数外的指令③跳转指令不只有短距离跳转，还有长距离跳转指令（ff15 call，ff25 jmp）。对比，我们的解决办法是：跟随跳转到被调用的子函数中，并个根据跳转方法是call还是jmp来判断跳转语句是否是此函数的最后一句。
- DontStarveLuaJIT判定函数开头采取的方法是上一字节是`0xC3`（ret）或`0x90`（单字节nop）方法，这种方法不准确，容易将内存对齐后的第一个指令识别为函数开头，并遗漏了jmp指令后的函数开头。因此，我们采用全局扫描方法，从`.text`段开始计算特征码，遇到jmp或ret函数则为函数结束，下一条指令为新函数开始，从而避免遗漏。
- DontStarveLuaJIT中对于每个lua51的函数，都搜索了一遍饥荒主程序的内存空间，这种方法费时费力，我们改为对每个饥荒内置函数计算一次特征值，然后对lua51和饥荒函数的两组特征值进行公共子序列计算作为其相似度，最后将相似度作为权重利用km算法进行匹配。
- 不知为何，我编译的lua51二进制与饥荒程序中的对比，在取`.rodata`中值的时候，有部分`lea`指令与`mov`指令不对应问题。这两条指令的作用基本相同，因此我们需要在生成特征码时将这两种指令统一。
- 在x64架构下，动态链接库的调用采用`GOT表`和`PLT表`方式[^7]。而在饥荒主程序内部静态编译的lua51则是直接调用，因此如果我们需要考虑拿到真实的函数语句来生成特征码。

#### 在上面我们尝试解决问题时是否引入了新的问题？

- 如果子函数很长，最终计算的特征码子函数权重过重，会影响匹配结果。

  解决办法：对特征码进行分级，子函数全部特征码在父函数中权重为一条语句

- 考虑`.got.plt`转发时，如果先加载luajit，根据Linux系统动态库函数搜索的说明，先搜索到的同名export函数是luajit中的，而非lua51中，因此在加载lua51时，其`.got.plt`中会被写入luajit中该函数的地址，从而导致特征码生成错误。如果先加载lua51，则会导致luajit库的`.got.plt`实际调用了lua51中的函数。

  解决办法：先加载lua51，不加载luajit，特征码计算完后卸载lua51，然后再加载luajit。

- 转换mov指令为lea指令后，由于其操作数为`.rodata`段中静态变量的地址，对于不同库中同一变量值，其地址也是不同的，仅将地址作为特征值不准确。

  解决办法：判断lea指令操作数是`.rodata`段中静态变量的地址后，将地址中的值取出作为此指令操作数的特征值。

- 我们计算了饥荒主程序代码段的全部特征码，并对子函数也进行了全采样，相较于DontStarveLuaJIT只取64字节的方法，运算量明显增加。

  解决办法：对计算结果进行缓存，通过摘要算法判断饥荒主程序是否更新，仅在第一次或更新后进行计算。

## 0x08 后记

整个实现过程大概耗费了我春节前后两周的时间，期间遇到最诡异的事情就是`.text`段内搜索不到任何的饥荒函数，甚至还有直接将bash卡死的事情发生，后来才发现原来是注入到exec中了，通过增加进程名验证解决。

这个项目让我对elf文件格式、linux进程空间、x86汇编有了很深的理解，也希望后来的小伙伴可以参考学习。具体迭代历史可以在[开发分支](https://github.com/zxcvbnm3057/Faster_DST/tree/LengthDisasm)中查看。

## 尾注

[^1]: 对于原版饥荒与现代cpu来说，这倒无可厚非
    
[^2]: 后来在经过考察验证，靠一己之力将饥荒改为多线程是不现实的。原因如下：①饥荒官方实现的class并没有考虑多线程同步的问题，其底层的lua table也没有考虑变量public，private的区分②绝大多数mod甚至官方代码中，并没有完全采用get/set来修改/读取类变量③多线程的主要思路是修改`scripts/update.lua`文件，将其中的`Updata`函数中逐个更新component、brain、sg拆入不同线程，而部分prefab可能将控制brain、sg的变量放在prefab中，贸然进行修改可能会导致严重的模组不兼容。
    
[^3]: 参考链接：
    
    - [硬编码学习笔记（二）—— 经典变长指令](https://blog.csdn.net/qq_41988448/article/details/115372556)
    - [X86 Opcode and Instruction Reference Home](http://ref.x86asm.net/geek32-abc.html)
    - [X86 Opcode and Instruction Reference Home](http://ref.x86asm.net/geek64.html)
    
[^4]: 参考《Intel Architecture Software Developer’s Manual Volume 2》，由于这是一系列文档，就不放链接了
    
[^5]: 我把相关指令创建了一个[Dockerfile](https://github.com/CN-DST-DEVELOPER/gcc-4.8.4/blob/main/Dockerfile)可以作为参考
    
[^6]: [INTEL X86 多字节NOP指令](https://www.cnblogs.com/ysjblog/p/15883438.html)
    
[^7]: [深入理解GOT表和PLT表](https://zhuanlan.zhihu.com/p/130271689)
